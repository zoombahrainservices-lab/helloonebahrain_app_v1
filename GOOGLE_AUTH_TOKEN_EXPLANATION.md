# Google Auth Token Explanation

## Why Multiple Tokens?

When you see multiple tokens in the OAuth callback URL, this is **NORMAL** and **EXPECTED**. Here's why:

### Token Breakdown:

1. **`access_token`** (JWT - JSON Web Token)
   - **Purpose**: Authenticate API requests to Supabase
   - **Expires**: 1 hour (3600 seconds)
   - **Format**: JWT (very long string)
   - **Contains**: User info, session data, permissions, expiration
   - **Used by**: Your app to make authenticated requests to Supabase

2. **`refresh_token`**
   - **Purpose**: Get new access tokens when they expire
   - **Expires**: Never (or very long time)
   - **Format**: Opaque string (short)
   - **Used by**: Your app to refresh `access_token` when it expires

3. **`provider_token`** (Google OAuth Token)
   - **Purpose**: Access Google APIs on behalf of the user
   - **Expires**: 1 hour
   - **Format**: Google OAuth token (starts with `ya29.`)
   - **Contains**: Google user info, permissions
   - **Used by**: If you need to call Google APIs (Gmail, Drive, etc.)

4. **`expires_at`** and **`expires_in`**
   - **Purpose**: Token expiration information
   - **Format**: Unix timestamp and seconds
   - **Used by**: Your app to know when to refresh tokens

## Token Flow:

```
User clicks "Continue with Google"
    ↓
Google authenticates user
    ↓
Google redirects to Supabase with OAuth code
    ↓
Supabase exchanges code for tokens:
    ├── access_token (Supabase JWT)
    ├── refresh_token (Supabase)
    ├── provider_token (Google OAuth token)
    └── expires_at/expires_in (expiration info)
    ↓
All tokens sent in callback URL hash (#access_token=...&refresh_token=...)
    ↓
App extracts tokens from URL
    ↓
App sets Supabase session with access_token and refresh_token
    ↓
Session stored in AsyncStorage
```

## Do We Need All Tokens?

### Required Tokens:
- ✅ **`access_token`**: **REQUIRED** - Used for all Supabase API calls
- ✅ **`refresh_token`**: **REQUIRED** - Used to refresh access_token when it expires

### Optional Tokens:
- ⚠️ **`provider_token`**: **OPTIONAL** - Only needed if you want to call Google APIs
- ⚠️ **`expires_at`/`expires_in`**: **OPTIONAL** - Nice to have for token management

## Current Implementation:

Our app currently:
1. ✅ Extracts `access_token` and `refresh_token` from URL
2. ✅ Sets Supabase session with these tokens
3. ✅ Stores session in AsyncStorage
4. ⚠️ Ignores `provider_token` (we don't need Google APIs)
5. ⚠️ Ignores `expires_at`/`expires_in` (Supabase handles expiration)

## Why So Many Tokens?

This is standard OAuth 2.0 flow:
- **Access Token**: Short-lived, for API calls
- **Refresh Token**: Long-lived, for getting new access tokens
- **Provider Token**: For accessing the provider's (Google's) APIs
- **Expiration Info**: For token management

Supabase returns all of them because:
1. Different apps need different tokens
2. Some apps need Google API access (provider_token)
3. Token expiration info helps with token management
4. It's the standard OAuth 2.0 response format

## Performance Impact:

**Multiple tokens do NOT slow down the login process.**

The tokens are:
- ✅ Already generated by Supabase
- ✅ Already in the callback URL
- ✅ Extracted in < 10ms
- ✅ Set in session in ~200ms

The slowness was caused by:
- ❌ `fetchMe()` running in parallel with OAuth
- ❌ Unnecessary delays
- ❌ Loading state not clearing immediately

**NOT** by multiple tokens.

## Summary:

- ✅ Multiple tokens are **NORMAL** and **EXPECTED**
- ✅ We only use `access_token` and `refresh_token`
- ✅ Other tokens are ignored (we don't need them)
- ✅ Tokens don't cause slowness
- ✅ The fix addresses the real performance issues (parallel fetchMe, delays, loading state)

